import { PDFDocument, StandardFonts, rgb, type PDFFont, type PDFPage } from "pdf-lib";
import type { ProviderResult } from "@/types/research";

export type PdfPayload = {
  title: string;
  userEmail: string;
  createdAt: string;
  openAi: ProviderResult | null;
  gemini: ProviderResult | null;
};

export async function buildResearchPdf(payload: PdfPayload): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  const regularFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const pages: PDFPage[] = [];
  const margin = 56;

  let currentPage: PDFPage;
  let cursorY = 0;
  let contentWidth = 0;

  const setCurrentPage = (page: PDFPage) => {
    currentPage = page;
    const { height, width } = currentPage.getSize();
    cursorY = height - margin;
    contentWidth = width - margin * 2;
  };

  const addPage = () => {
    const page = pdfDoc.addPage();
    pages.push(page);
    setCurrentPage(page);
    return page;
  };

  const lineHeightFor = (size: number) => size * 1.35;

  const ensureSpace = (lineHeight: number) => {
    if (cursorY - lineHeight < margin) {
      addPage();
    }
  };

  const wrapText = (text: string, font: PDFFont, size: number): string[] => {
    const sanitized = text
      .replace(/\r\n/g, "\n")
      .split("\n")
      .map((line) => line.trim());

    const lines: string[] = [];

    for (const segment of sanitized) {
      if (segment.length === 0) {
        lines.push("");
        continue;
      }

      const words = segment.split(/\s+/);
      let currentLine = "";

      for (const word of words) {
        const tentative = currentLine.length > 0 ? `${currentLine} ${word}` : word;
        const width = font.widthOfTextAtSize(tentative, size);

        if (width <= contentWidth) {
          currentLine = tentative;
          continue;
        }

        if (currentLine.length > 0) {
          lines.push(currentLine);
          currentLine = word;
          continue;
        }

        lines.push(word);
        currentLine = "";
      }

      if (currentLine.length > 0) {
        lines.push(currentLine);
      }

      lines.push("");
    }

    while (lines.length > 0 && lines[lines.length - 1] === "") {
      lines.pop();
    }

    return lines;
  };

  const writeLines = ({
    text,
    font = regularFont,
    size = 12,
    color = rgb(0.1, 0.1, 0.1),
    indent = 0,
    spacing = lineHeightFor(size)
  }: {
    text: string;
    font?: PDFFont;
    size?: number;
    color?: ReturnType<typeof rgb>;
    indent?: number;
    spacing?: number;
  }) => {
    const lines = wrapText(text, font, size);

    for (const line of lines) {
      if (line === "") {
        cursorY -= spacing * 0.5;
        continue;
      }

      ensureSpace(spacing);
      currentPage.drawText(line, {
        x: margin + indent,
        y: cursorY,
        size,
        font,
        color
      });

      cursorY -= spacing;
    }
  };

  const writeHeading = (text: string, level: 1 | 2 | 3) => {
    const size = level === 1 ? 20 : level === 2 ? 16 : 13;
    const spacing = lineHeightFor(size);
    ensureSpace(spacing * 1.5);
    cursorY -= spacing * 0.3;
    writeLines({
      text,
      font: boldFont,
      size
    });
    cursorY -= spacing * 0.4;
  };

  const writeList = (items: string[]) => {
    if (!items.length) {
      return;
    }

    for (const item of items) {
      writeLines({
        text: `• ${item}`,
        indent: 14
      });
    }
  };

  // --- Cover page ---
  const coverPage = addPage();
  const { height: coverHeight } = coverPage.getSize();

  writeLines({
    text: `Research Title: ${payload.title}`,
    font: boldFont,
    size: 16
  });
  writeLines({
    text: `Prepared for: ${payload.userEmail}`,
    size: 12
  });
  writeLines({
    text: `Created at: ${payload.createdAt}`,
    size: 12
  });

  const drawCentered = (text: string, y: number, size: number, font: PDFFont) => {
    const { width } = coverPage.getSize();
    const textWidth = font.widthOfTextAtSize(text, size);
    coverPage.drawText(text, {
      x: Math.max(margin, (width - textWidth) / 2),
      y,
      size,
      font,
      color: rgb(0.1, 0.1, 0.1)
    });
  };

  const heroTitleY = coverHeight - 140;
  const heroSubtitleY = heroTitleY - 34;

  drawCentered("Multi-API Research Assistant", heroTitleY, 26, boldFont);
  drawCentered("Comparative Research Report", heroSubtitleY, 20, regularFont);

  const summaryStart = Math.min(cursorY - lineHeightFor(12), heroSubtitleY - 48);
  cursorY = Math.max(summaryStart, margin);

  writeLines({
    text: "This report compares findings generated by OpenAI Deep Research and Google Gemini using the finalized research prompt."
  });

  // Start a fresh page for provider content.
  addPage();

  const renderProviderSection = (label: string, result: ProviderResult | null) => {
    writeHeading(label, 1);

    if (!result) {
      writeLines({
        text: "No findings were recorded for this provider. The provider may have failed or has not run yet."
      });
      cursorY -= lineHeightFor(12);
      return;
    }

    if (result.summary) {
      writeHeading("Summary", 2);
      writeLines({ text: result.summary });
      cursorY -= lineHeightFor(12);
    }

    if (result.insights?.length) {
      writeHeading("Key Insights", 2);
      writeList(result.insights);
      cursorY -= lineHeightFor(12);
    }

    if (result.sources?.length) {
      writeHeading("Sources", 2);
      result.sources.forEach((source, index) => {
        writeLines({
          text: `${index + 1}. ${source.title}`,
          font: boldFont,
          size: 12
        });
        if (source.url) {
          writeLines({
            text: source.url,
            size: 11,
            color: rgb(0, 0.27, 0.53)
          });
        }
        cursorY -= lineHeightFor(11) * 0.5;
      });
    }

    if (result.meta) {
      const metaLines: string[] = [];
      if (result.meta.model) {
        metaLines.push(`Model: ${result.meta.model}`);
      }
      if (result.meta.tokens !== undefined) {
        metaLines.push(`Tokens: ${result.meta.tokens}`);
      }
      if (result.meta.startedAt) {
        metaLines.push(`Started: ${result.meta.startedAt}`);
      }
      if (result.meta.completedAt) {
        metaLines.push(`Completed: ${result.meta.completedAt}`);
      }

      if (metaLines.length > 0) {
        writeHeading("Metadata", 3);
        metaLines.forEach((line) => {
          writeLines({ text: line });
        });
      }
    }

    cursorY -= lineHeightFor(12) * 0.75;
  };

  renderProviderSection("OpenAI Deep Research", payload.openAi);
  addPage();
  renderProviderSection("Google Gemini", payload.gemini);

  const footerBase = `Generated ${payload.createdAt} • Multi-API Research Assistant`;

  pages.forEach((page, index) => {
    const footerSize = 10;
    const { width } = page.getSize();
    const footerText = `${footerBase} • Page ${index + 1} of ${pages.length}`;
    const textWidth = regularFont.widthOfTextAtSize(footerText, footerSize);

    page.drawText(footerText, {
      x: Math.max(margin, (width - textWidth) / 2),
      y: margin / 2,
      size: footerSize,
      font: regularFont,
      color: rgb(0.4, 0.4, 0.4)
    });
  });

  return pdfDoc.save();
}
